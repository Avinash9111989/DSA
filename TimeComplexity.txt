What is Time Complexity?

Time Complexity = How the running time of an algorithm grows with respect to the input size n.

It doesnâ€™t measure exact seconds, but the number of steps or operations.

Expressed using Big-O Notation: O(f(n))

ðŸ”¹ Common Time Complexities
1. Constant Time â†’ O(1)

Running time does not depend on input size.

Example:

int x = 10;      // O(1)
printf("%d", x); // O(1)


âœ… Always executes in the same time.

2. Logarithmic Time â†’ O(log n)

Each step reduces the problem size by half.

Example: Binary Search

int binarySearch(int arr[], int n, int key) {
    int low = 0, high = n - 1;
    while(low <= high) {
        int mid = (low + high) / 2;
        if(arr[mid] == key) return mid;   // O(1)
        else if(arr[mid] < key) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}


âœ… Time Complexity: O(log n)

3. Linear Time â†’ O(n)

Execution grows proportional to input size.

Example: Traverse array with pointer

void printArray(int *arr, int n) {
    for(int i=0; i<n; i++) {
        printf("%d ", *(arr+i));  // runs n times
    }
}


âœ… Time Complexity: O(n)

4. Linearithmic Time â†’ O(n log n)

Common in sorting algorithms like Merge Sort, Quick Sort.

Example: Merge Sort splits array (log n times) and processes each element (n).

âœ… Time Complexity: O(n log n)

5. Quadratic Time â†’ O(nÂ²)

Nested loops â†’ runs n * n times.

Example: Bubble Sort

void bubbleSort(int *arr, int n) {
    for(int i=0; i<n; i++) {        // O(n)
        for(int j=0; j<n-i-1; j++) { // O(n)
            if(arr[j] > arr[j+1]) {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}


âœ… Time Complexity: O(nÂ²)

6. Cubic Time â†’ O(nÂ³)

Triple nested loops.

Example: Matrix Multiplication (n x n matrices).

7. Exponential Time â†’ O(2^n)

Doubles with each additional input.

Example: Recursive Fibonacci

int fib(int n) {
    if(n <= 1) return n;
    return fib(n-1) + fib(n-2);
}


âœ… Time Complexity: O(2^n)

8. Factorial Time â†’ O(n!)

Extremely slow.

Example: Solving Traveling Salesman Problem using brute force.

ðŸ”¹ Big-O Notation Summary Table
Complexity	Example	Performance
O(1)	Access array element by index	Best
O(log n)	Binary search	Very good
O(n)	Linear search, traversal	Good
O(n log n)	Merge sort, quicksort (avg)	Efficient
O(nÂ²)	Bubble sort, insertion sort	Slow
O(nÂ³)	Matrix multiplication	Slower
O(2^n)	Recursive Fibonacci	Very slow
O(n!)	Traveling Salesman brute force	Worst
ðŸ”¹ Pointer Program Examples with Time Complexity

Print array using pointer â†’ O(n)

Reverse array using pointer â†’ O(n)

Swap two numbers using pointer â†’ O(1)

String length using pointer â†’ O(n)

Concatenate two strings using pointer â†’ O(m+n) (m = length of str1, n = length of str2)

Sort array using pointers (Bubble Sort) â†’ O(nÂ²)

Dynamic memory allocation & filling â†’ O(n)

Function pointer calls â†’ O(1)

Pointer to structure (access fields) â†’ O(1)

Stack using pointers â†’ Push/Pop O(1), Traverse O(n)